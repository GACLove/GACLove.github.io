{"meta":{"title":"Hexo","subtitle":"","description":"","author":"gaopeng","url":"http://gaclove.github.io","root":"/"},"pages":[{"title":"404","date":"2022-12-31T16:00:00.000Z","updated":"2023-02-03T07:30:45.579Z","comments":true,"path":"404/index.html","permalink":"http://gaclove.github.io/404/index.html","excerpt":"","text":""},{"title":"about","date":"2023-01-31T03:14:29.000Z","updated":"2023-02-03T07:30:45.579Z","comments":true,"path":"about/index.html","permalink":"http://gaclove.github.io/about/index.html","excerpt":"","text":""},{"title":"archives","date":"2023-01-31T03:18:50.000Z","updated":"2023-02-03T07:30:45.579Z","comments":true,"path":"archives/index.html","permalink":"http://gaclove.github.io/archives/index.html","excerpt":"","text":""},{"title":"categories","date":"2023-01-31T03:21:29.000Z","updated":"2023-02-03T07:30:45.579Z","comments":true,"path":"categories/index.html","permalink":"http://gaclove.github.io/categories/index.html","excerpt":"","text":""},{"title":"contact","date":"2023-01-31T03:15:30.000Z","updated":"2023-02-03T07:30:45.579Z","comments":true,"path":"contact/index.html","permalink":"http://gaclove.github.io/contact/index.html","excerpt":"","text":""},{"title":"tags","date":"2023-01-31T03:13:31.000Z","updated":"2023-02-03T07:30:45.579Z","comments":true,"path":"tags/index.html","permalink":"http://gaclove.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"CUDA常见错误排查","slug":"CUDA常见错误排查","date":"2019-12-27T13:18:12.000Z","updated":"2023-02-03T07:30:45.579Z","comments":true,"path":"CUDA常见错误排查/","link":"","permalink":"http://gaclove.github.io/CUDA%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E6%8E%92%E6%9F%A5/","excerpt":"","text":"常见的错误说明 https://zhuanlan.zhihu.com/p/360727546 排查工具 cuda-memcheck，在cuda11.0 之后就不建议使用了。 CUDA11.0 之后提供了 compute-sanitizer, 具体使用参考官方示例： https://github.com/NVIDIA/compute-sanitizer-samples","categories":[{"name":"NVIDIA","slug":"NVIDIA","permalink":"http://gaclove.github.io/categories/NVIDIA/"}],"tags":[{"name":"NVIDIA","slug":"NVIDIA","permalink":"http://gaclove.github.io/tags/NVIDIA/"}]},{"title":"弱符号_弱引用","slug":"强弱符号_强弱引用","date":"2019-04-30T14:28:10.000Z","updated":"2023-02-03T07:30:45.579Z","comments":true,"path":"强弱符号_强弱引用/","link":"","permalink":"http://gaclove.github.io/%E5%BC%BA%E5%BC%B1%E7%AC%A6%E5%8F%B7_%E5%BC%BA%E5%BC%B1%E5%BC%95%E7%94%A8/","excerpt":"","text":"弱符号、弱引用的扩展机制在库的实现中非常有用。我们在库中可以使用弱符号和弱引用机制，这样对于一个弱符号函数而言，用户可以自定义扩展功能的函数来覆盖这个弱符号函数。 同时我们可以将某些扩展功能函数定义为弱引用，当用户需要使用扩展功能时，就对其进行定义，链接到程序当中，如果用户不进行定义，则链接也不会报错，这使得库的功能可以很方便地进行裁剪和组合。 弱符号示例 &#x2F;&#x2F; test.h void test_func(void) &#123; weak_func(); &#125; &#x2F;&#x2F; test.c #include &lt;stdio.h&gt; void __attribute__((weak)) weak_func(void) &#123; printf(&quot;defualt weak func is running!\\n&quot;); &#125; void test_func(void) &#123; weak_func(); &#125; 使用弱符号 &#x2F;&#x2F; main.c #include &lt;stdio.h&gt; #include &quot;test.h&quot; int main() &#123; test_func(); return 0; &#125; &#x2F;&#x2F; ❯ .&#x2F;test &#x2F;&#x2F; defualt weak func is running! 外部强符号，覆盖弱符号 &#x2F;&#x2F; main.c #include &lt;stdio.h&gt; #include &quot;test.h&quot; void weak_func(void) &#123; printf(&quot;custom strong func override!\\n&quot;); &#125; int main() &#123; test_func(); return 0; &#125; &#x2F;&#x2F;❯ .&#x2F;test &#x2F;&#x2F;custom strong func override! 弱引用示例 &#x2F;&#x2F;test.h void test_func(void); &#x2F;&#x2F;test.c #include &lt;stdio.h&gt; &#x2F;&#x2F; 具体定义： https:&#x2F;&#x2F;gcc.gnu.org&#x2F;onlinedocs&#x2F;gcc-4.3.6&#x2F;gcc&#x2F;Function-Attributes.html static __attribute__((weakref(&quot;test&quot;))) void weak_ref(void); void test_func(void) &#123; if (weak_ref) &#123; weak_ref(); &#125; else &#123; printf(&quot;weak ref function is null\\n&quot;); &#125; &#125; &#x2F;&#x2F;build command &#x3D;&gt; libtest.a gcc -c test.c; ar -rsc libtest.a test.o main.c &#x2F;&#x2F; 使用默认 #include &lt;stdio.h&gt; #include &lt;stdarg.h&gt; #include &quot;test.h&quot; int main() &#123; test_func(); return 0; &#125; &#x2F;&#x2F;gcc main.c test.h -L. -ltest -o test &#x2F;&#x2F;&gt; weak ref function is null &#x2F;&#x2F; 使用外部定义 #include &lt;stdio.h&gt; #include &lt;stdarg.h&gt; #include &quot;test.h&quot; void test(void) &#123; printf(&quot;running custom weak ref function!\\n&quot;); &#125; int main() &#123; test_func(); return 0; &#125; &#x2F;&#x2F;gcc main.c test.h -L. -ltest -o test &#x2F;&#x2F;&gt; running custom weak ref function!","categories":[{"name":"GCC","slug":"GCC","permalink":"http://gaclove.github.io/categories/GCC/"}],"tags":[{"name":"Linux GCC","slug":"Linux-GCC","permalink":"http://gaclove.github.io/tags/Linux-GCC/"}]},{"title":"nvidia-smi常用命令","slug":"nvidia-smi常用命令","date":"2018-07-30T12:28:18.000Z","updated":"2023-02-03T07:30:45.579Z","comments":true,"path":"nvidia-smi常用命令/","link":"","permalink":"http://gaclove.github.io/nvidia-smi%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"支持的可选项 MEMORY, UTILIZATION, ECC, TEMPERATURE, POWER, CLOCK, COMPUTE, PIDS, PERFORMANCE, SUPPORTED_CLOCKS, PAGE_RETIREMENT, ACCOUNTING, ENCODER_STATS, SUPPORTED_GPU_TARGET_TEMP, VOLTAGE FBC_STATS, ROW_REMAPPER 查询某项的值 nvidia-smi -q -d &lt;xxx> 示例： #查询MEM,SM 最大频率 nvidia-smi -q -d CLOCK 设置MEM, SM 频率（用于性能测试） # 查询当前卡的频率 nvidia-smi -q -d CLOCK # 锁定频率 nvidia-smi -ac 5001,1590 # 重置到 auto nvidia-smi -rac Windows上多个CUDA切换 # window 平台切换 cuda 版本 (powershell) $env:CUDA_PATH=\"C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v&lt;xxx>\" 查询GPU各资源的利用率 # 间隔1s 输出0号卡各状态 nvidia-smi dmon -i 0 -d 1 输出示例: # gpu pwr gtemp mtemp sm mem enc dec mclk pclk # Idx W C C % % % % MHz MHz 0 15 88 - 0 7 0 0 405 139 0 11 88 - 0 6 0 0 405 151","categories":[{"name":"NVIDIA","slug":"NVIDIA","permalink":"http://gaclove.github.io/categories/NVIDIA/"}],"tags":[{"name":"NVIDIA","slug":"NVIDIA","permalink":"http://gaclove.github.io/tags/NVIDIA/"}]},{"title":"GCC常用选项","slug":"GCC常用选项","date":"2018-04-30T12:28:18.000Z","updated":"2023-02-03T07:30:45.579Z","comments":true,"path":"GCC常用选项/","link":"","permalink":"http://gaclove.github.io/GCC%E5%B8%B8%E7%94%A8%E9%80%89%E9%A1%B9/","excerpt":"","text":"命令常用 Gcc 命令本身就有很多可以使用文档， 如果对编译和链接过程需要有详细控制的，可以细看 gcc 文档 gcc -dumpmachine # 打印当前机器信息, 示例： # output: x86_64-linux-gnu gcc -print-search-dirs # 打印搜索路径 gcc --help&#x3D;target # 可以查看可以详细控制的选项 # 查看当前C++编译器 ABI 兼容问题, 参考： # https:&#x2F;&#x2F;gcc.gnu.org&#x2F;onlinedocs&#x2F;libstdc++&#x2F;manual&#x2F;using_dual_abi.html echo &#39;#include &lt;string&gt; &#39; | g++ -dM -E -x c++ - | grep _GLIBCXX_USE_CXX11_ABI # 查看当前C++编译器是否支持symbol version # https:&#x2F;&#x2F;refspecs.linuxfoundation.org&#x2F;LSB_3.0.0&#x2F;LSB-PDA&#x2F;LSB-PDA.junk&#x2F;symversion.html echo &#39;#include &lt;string&gt; &#39; | g++ -dM -E -x c++ - | grep _GLIBCXX_SYMVER 编译常见 安全相关的编译选项 在编译器层面，gcc提供了不少安全方面的编译选项，主要有： # NX(DEP) -z execstack # 禁用NX保护 -z noexecstack # 开启NX保护| 堆栈禁止执行 # RELRO -z norelro # 关闭 -z lazy # 部分开启 -z now # 全部开启| GOT写保护 # CANARY -fno -stack-protector # 禁用 -fstack-protector # 开启 -fstack-protector-all # 完全开启| 堆栈溢出哨兵 # FORTIFY -D_FORTIFY_SOURCE &#x3D;1 # 较弱的检查 -D_FORTIFY_SOURCE&#x3D;2 # 较强的检查| 常用函数加强检查 # PIE(ASLR) -fpie -pie # 开启PIE，此时强度为1 -fPIE -pie # 开启PIE，此时为最高强度2| 代码段、数据段地址随机化 Ref Gcc 安全编译选项","categories":[{"name":"GCC","slug":"GCC","permalink":"http://gaclove.github.io/categories/GCC/"}],"tags":[{"name":"Linux GCC","slug":"Linux-GCC","permalink":"http://gaclove.github.io/tags/Linux-GCC/"}]}],"categories":[{"name":"NVIDIA","slug":"NVIDIA","permalink":"http://gaclove.github.io/categories/NVIDIA/"},{"name":"GCC","slug":"GCC","permalink":"http://gaclove.github.io/categories/GCC/"}],"tags":[{"name":"NVIDIA","slug":"NVIDIA","permalink":"http://gaclove.github.io/tags/NVIDIA/"},{"name":"Linux GCC","slug":"Linux-GCC","permalink":"http://gaclove.github.io/tags/Linux-GCC/"}]}