{"meta":{"title":"Hexo","subtitle":"","description":"","author":"gaopeng","url":"http://gaclove.github.io","root":"/"},"pages":[{"title":"404","date":"2022-12-31T16:00:00.000Z","updated":"2023-10-16T10:07:41.623Z","comments":true,"path":"404/index.html","permalink":"http://gaclove.github.io/404/","excerpt":"","text":""},{"title":"关于","date":"2023-01-31T03:14:29.000Z","updated":"2023-10-16T10:07:41.623Z","comments":true,"path":"about/index.html","permalink":"http://gaclove.github.io/about/","excerpt":"","text":""},{"title":"归档","date":"2023-01-31T03:18:50.000Z","updated":"2023-10-16T10:07:41.623Z","comments":true,"path":"archives/index.html","permalink":"http://gaclove.github.io/archives/","excerpt":"","text":""},{"title":"分类","date":"2023-01-31T03:21:29.000Z","updated":"2023-10-16T10:07:41.623Z","comments":true,"path":"categories/index.html","permalink":"http://gaclove.github.io/categories/","excerpt":"","text":""},{"title":"联系","date":"2023-01-31T03:15:30.000Z","updated":"2023-10-16T10:07:41.623Z","comments":true,"path":"contact/index.html","permalink":"http://gaclove.github.io/contact/","excerpt":"","text":""},{"title":"标签","date":"2023-01-31T03:13:31.000Z","updated":"2023-10-16T10:07:41.623Z","comments":true,"path":"tags/index.html","permalink":"http://gaclove.github.io/tags/","excerpt":"","text":""}],"posts":[{"title":"常用的端口","slug":"常用的端口","date":"2021-10-16T10:02:40.000Z","updated":"2023-10-16T10:07:41.623Z","comments":true,"path":"/常用的端口/","link":"","permalink":"http://gaclove.github.io/%E5%B8%B8%E7%94%A8%E7%9A%84%E7%AB%AF%E5%8F%A3/","excerpt":"","text":"默认端口/路径信息 服务类型 3306 Mysql系统服务 1433 微软SQL服务 9030 doris系统服务 6379 redis系统服务 1521 oracle系统服务 8123 clickhouse系统服务 9092 Kafka服务 2049 nfs服务 9200/9300 Elasticsearch服务 22 Ssh服务 20/21 ftp服务 161 SNMP服务 23 Telnet服务 3389 RDP 远程桌面 5901 Vnc服务 139/445 SMB服务 111 rpnbind 30000-32767 k8s 默认映射范围","categories":[],"tags":[{"name":"port","slug":"port","permalink":"http://gaclove.github.io/tags/port/"}]},{"title":"ffmpeg-prebuit的下载链接","slug":"ffmpeg-prebuit的下载链接","date":"2021-05-10T10:34:36.000Z","updated":"2023-10-16T10:07:41.623Z","comments":true,"path":"/ffmpeg-prebuit的下载链接/","link":"","permalink":"http://gaclove.github.io/ffmpeg-prebuit%E7%9A%84%E4%B8%8B%E8%BD%BD%E9%93%BE%E6%8E%A5/","excerpt":"","text":"FFmpeg 预编译的libray和可执行程序 github下载链接 From https://github.com/BtbN/FFmpeg-Builds/ 的文档： FFmpeg Static Auto-Builds Static Windows (x86_64) and Linux (x86_64) Builds of ffmpeg master and latest release branch. Windows builds are targetting Windows 7 and newer. Linux (x86_64) builds are targetting Ubuntu 16.04 (glibc-2.23 + linux-4.4) and anything more recent. Linux (arm64) builds are targetting Ubuntu 18.04 (glibc-2.27 + linux-4.15) and anything more recent. Auto-Builds Builds run daily at 12:00 UTC (or GitHubs idea of that time) and are automatically released on success. Auto-Builds run ONLY for win64 and linux(arm)64. There are no win32/x86 auto-builds, though you can produce win32 builds yourself following the instructions below. Release Retention Policy The last build of each month is kept for two years. The last 14 daily builds are kept. The special “latest” build floats and provides consistent URLs always pointing to the latest build. Package List For a list of included dependencies check the scripts.d directory. Every file corresponds to its respective package. How to make a build Prerequisites bash docker Build Image ./makeimage.sh target variant [addin [addin] [addin] ...] Build FFmpeg ./build.sh target variant [addin [addin] [addin] ...] On success, the resulting zip file will be in the artifacts subdir. Targets, Variants and Addins Available targets: win64 (x86_64 Windows) win32 (x86 Windows) linux64 (x86_64 Linux, glibc&gt;=2.23, linux&gt;=4.4) linuxarm64 (arm64 (aarch64) Linux, glibc&gt;=2.27, linux&gt;=4.15) The linuxarm64 target will not build some dependencies due to lack of arm64 (aarch64) architecture support or cross-compiling restrictions. davs2 and xavs2: aarch64 support is broken. libmfx and libva: Library for Intel QSV, so there is no aarch64 support. Available variants: gpl Includes all dependencies, even those that require full GPL instead of just LGPL. lgpl Lacking libraries that are GPL-only. Most prominently libx264 and libx265. nonfree Includes fdk-aac in addition to all the dependencies of the gpl variant. gpl-shared Same as gpl, but comes with the libav* family of shared libs instead of pure static executables. lgpl-shared Same again, but with the lgpl set of dependencies. nonfree-shared Same again, but with the nonfree set of dependencies. All of those can be optionally combined with any combination of addins: 4.4 to build from the 4.4 release branch instead of master. 5.0 to build from the 5.0 release branch instead of master. 5.1 to build from the 5.1 release branch instead of master. debug to not strip debug symbols from the binaries. This increases the output size by about 250MB. lto build all dependencies and ffmpeg with -flto=auto (HIGHLY EXPERIMENTAL, broken for Windows, sometimes works for Linux)","categories":[{"name":"tools","slug":"tools","permalink":"http://gaclove.github.io/categories/tools/"}],"tags":[{"name":"ffmpeg","slug":"ffmpeg","permalink":"http://gaclove.github.io/tags/ffmpeg/"}]},{"title":"Flask快速上手","slug":"flask快速上手","date":"2021-05-10T10:34:36.000Z","updated":"2023-10-16T10:07:41.623Z","comments":true,"path":"/flask快速上手/","link":"","permalink":"http://gaclove.github.io/flask%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/","excerpt":"","text":"xx 1. 启动命令中添加 Gunicorn 的 --reload 选项，这将启用 Gunicorn 的自动重载功能，并在代码更改时重新启动应用程序 gunicorn --bind 0.0.0.0:8000 --reload --access-logfile '-' app:app 2. 设置 Flask 应用程序的 debug 标志，以便在调试模式下运行应用程序。 if __name__ == '__main__': app.run(debug=True) 3. 使用 Flask 的调试器，您需要禁用 Gunicorn 的访问日志，以便在控制台上查看调试器输出。 gunicorn --bind 0.0.0.0:8000 --reload --access-logfile '-' app:app 远程调试flask 参考：https://dev.to/pacheco/dockerize-a-flask-app-and-debug-with-vscode-34i1 launch.json &#123; \"configurations\": [ &#123; \"name\": \"Python: Remote Attach\", \"type\": \"python\", \"request\": \"attach\", \"port\": 5678, \"host\": \"0.0.0.0\", \"pathMappings\": [ &#123; \"localRoot\": \"$&#123;workspaceFolder&#125;\", \"remoteRoot\": \"/code\" &#125; ] &#125; ] &#125; docker-compose.yml FLASK_APP: manage:app entrypoint: [ \"python\", \"-m\", \"debugpy\", \"--listen\", \"0.0.0.0:5678\", \"-m\", \"manage\", \"--wait-for-client\", \"--multiprocess\", \"-m\", \"flask\", \"run\", \"-h\", \"0.0.0.0\", \"-p\", \"5000\" ] ports: - 5000:5000 - 5678:5678 中文返回 app.config[“JSON_AS_ASCII”] = False app.config[“RESTFUL_JSON”] = {“ensure_ascii”: False} session中概念 id, name S: session ID 通过cookie 给出","categories":[{"name":"tools","slug":"tools","permalink":"http://gaclove.github.io/categories/tools/"}],"tags":[{"name":"python web flask","slug":"python-web-flask","permalink":"http://gaclove.github.io/tags/python-web-flask/"}]},{"title":"CUDA常见错误排查","slug":"CUDA常见错误排查","date":"2019-12-27T13:18:12.000Z","updated":"2023-10-16T10:07:41.623Z","comments":true,"path":"/CUDA常见错误排查/","link":"","permalink":"http://gaclove.github.io/CUDA%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E6%8E%92%E6%9F%A5/","excerpt":"","text":"常见的错误说明 https://zhuanlan.zhihu.com/p/360727546 排查工具 cuda-memcheck，在cuda11.0 之后就不建议使用了。 CUDA11.0 之后提供了 compute-sanitizer, 具体使用参考官方示例： https://github.com/NVIDIA/compute-sanitizer-samples","categories":[{"name":"NVIDIA","slug":"NVIDIA","permalink":"http://gaclove.github.io/categories/NVIDIA/"}],"tags":[{"name":"NVIDIA","slug":"NVIDIA","permalink":"http://gaclove.github.io/tags/NVIDIA/"}]},{"title":"弱符号_弱引用","slug":"强弱符号_强弱引用","date":"2019-04-30T14:28:10.000Z","updated":"2023-10-16T10:07:41.623Z","comments":true,"path":"/强弱符号_强弱引用/","link":"","permalink":"http://gaclove.github.io/%E5%BC%BA%E5%BC%B1%E7%AC%A6%E5%8F%B7_%E5%BC%BA%E5%BC%B1%E5%BC%95%E7%94%A8/","excerpt":"","text":"弱符号、弱引用的扩展机制在库的实现中非常有用。我们在库中可以使用弱符号和弱引用机制，这样对于一个弱符号函数而言，用户可以自定义扩展功能的函数来覆盖这个弱符号函数。 同时我们可以将某些扩展功能函数定义为弱引用，当用户需要使用扩展功能时，就对其进行定义，链接到程序当中，如果用户不进行定义，则链接也不会报错，这使得库的功能可以很方便地进行裁剪和组合。 弱符号示例 &#x2F;&#x2F; test.h void test_func(void) &#123; weak_func(); &#125; &#x2F;&#x2F; test.c #include &lt;stdio.h&gt; void __attribute__((weak)) weak_func(void) &#123; printf(&quot;defualt weak func is running!\\n&quot;); &#125; void test_func(void) &#123; weak_func(); &#125; 使用弱符号 &#x2F;&#x2F; main.c #include &lt;stdio.h&gt; #include &quot;test.h&quot; int main() &#123; test_func(); return 0; &#125; &#x2F;&#x2F; ❯ .&#x2F;test &#x2F;&#x2F; defualt weak func is running! 外部强符号，覆盖弱符号 &#x2F;&#x2F; main.c #include &lt;stdio.h&gt; #include &quot;test.h&quot; void weak_func(void) &#123; printf(&quot;custom strong func override!\\n&quot;); &#125; int main() &#123; test_func(); return 0; &#125; &#x2F;&#x2F;❯ .&#x2F;test &#x2F;&#x2F;custom strong func override! 弱引用示例 &#x2F;&#x2F;test.h void test_func(void); &#x2F;&#x2F;test.c #include &lt;stdio.h&gt; &#x2F;&#x2F; 具体定义： https:&#x2F;&#x2F;gcc.gnu.org&#x2F;onlinedocs&#x2F;gcc-4.3.6&#x2F;gcc&#x2F;Function-Attributes.html static __attribute__((weakref(&quot;test&quot;))) void weak_ref(void); void test_func(void) &#123; if (weak_ref) &#123; weak_ref(); &#125; else &#123; printf(&quot;weak ref function is null\\n&quot;); &#125; &#125; &#x2F;&#x2F;build command &#x3D;&gt; libtest.a gcc -c test.c; ar -rsc libtest.a test.o main.c &#x2F;&#x2F; 使用默认 #include &lt;stdio.h&gt; #include &lt;stdarg.h&gt; #include &quot;test.h&quot; int main() &#123; test_func(); return 0; &#125; &#x2F;&#x2F;gcc main.c test.h -L. -ltest -o test &#x2F;&#x2F;&gt; weak ref function is null &#x2F;&#x2F; 使用外部定义 #include &lt;stdio.h&gt; #include &lt;stdarg.h&gt; #include &quot;test.h&quot; void test(void) &#123; printf(&quot;running custom weak ref function!\\n&quot;); &#125; int main() &#123; test_func(); return 0; &#125; &#x2F;&#x2F;gcc main.c test.h -L. -ltest -o test &#x2F;&#x2F;&gt; running custom weak ref function!","categories":[{"name":"GCC","slug":"GCC","permalink":"http://gaclove.github.io/categories/GCC/"}],"tags":[{"name":"Linux GCC","slug":"Linux-GCC","permalink":"http://gaclove.github.io/tags/Linux-GCC/"}]},{"title":"nvidia-smi常用命令","slug":"nvidia-smi常用命令","date":"2018-07-30T12:28:18.000Z","updated":"2023-10-16T10:07:41.623Z","comments":true,"path":"/nvidia-smi常用命令/","link":"","permalink":"http://gaclove.github.io/nvidia-smi%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"支持的可选项 MEMORY, UTILIZATION, ECC, TEMPERATURE, POWER, CLOCK, COMPUTE, PIDS, PERFORMANCE, SUPPORTED_CLOCKS, PAGE_RETIREMENT, ACCOUNTING, ENCODER_STATS, SUPPORTED_GPU_TARGET_TEMP, VOLTAGE FBC_STATS, ROW_REMAPPER 查询某项的值 nvidia-smi -q -d &lt;xxx> 示例： #查询MEM,SM 最大频率 nvidia-smi -q -d CLOCK 设置MEM, SM 频率（用于性能测试） # 查询当前卡的频率 nvidia-smi -q -d CLOCK # 锁定频率 nvidia-smi -ac 5001,1590 # 重置到 auto nvidia-smi -rac Windows上多个CUDA切换 # window 平台切换 cuda 版本 (powershell) $env:CUDA_PATH=\"C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v&lt;xxx>\" 查询GPU各资源的利用率 # 间隔1s 输出0号卡各状态 nvidia-smi dmon -i 0 -d 1 输出示例: # gpu pwr gtemp mtemp sm mem enc dec mclk pclk # Idx W C C % % % % MHz MHz 0 15 88 - 0 7 0 0 405 139 0 11 88 - 0 6 0 0 405 151","categories":[{"name":"NVIDIA","slug":"NVIDIA","permalink":"http://gaclove.github.io/categories/NVIDIA/"}],"tags":[{"name":"NVIDIA","slug":"NVIDIA","permalink":"http://gaclove.github.io/tags/NVIDIA/"}]},{"title":"GCC常用选项","slug":"GCC常用选项","date":"2018-04-30T12:28:18.000Z","updated":"2023-10-16T10:07:41.623Z","comments":true,"path":"/GCC常用选项/","link":"","permalink":"http://gaclove.github.io/GCC%E5%B8%B8%E7%94%A8%E9%80%89%E9%A1%B9/","excerpt":"","text":"命令常用 Gcc 命令本身就有很多可以使用文档， 如果对编译和链接过程需要有详细控制的，可以细看 gcc 文档 gcc -dumpmachine # 打印当前机器信息, 示例： # output: x86_64-linux-gnu gcc -print-search-dirs # 打印搜索路径 gcc --help&#x3D;target # 可以查看可以详细控制的选项 # 查看当前C++编译器 ABI 兼容问题, 参考： # https:&#x2F;&#x2F;gcc.gnu.org&#x2F;onlinedocs&#x2F;libstdc++&#x2F;manual&#x2F;using_dual_abi.html echo &#39;#include &lt;string&gt; &#39; | g++ -dM -E -x c++ - | grep _GLIBCXX_USE_CXX11_ABI # 查看当前C++编译器是否支持symbol version # https:&#x2F;&#x2F;refspecs.linuxfoundation.org&#x2F;LSB_3.0.0&#x2F;LSB-PDA&#x2F;LSB-PDA.junk&#x2F;symversion.html echo &#39;#include &lt;string&gt; &#39; | g++ -dM -E -x c++ - | grep _GLIBCXX_SYMVER 编译常见 安全相关的编译选项 在编译器层面，gcc提供了不少安全方面的编译选项，主要有： # NX(DEP) -z execstack # 禁用NX保护 -z noexecstack # 开启NX保护| 堆栈禁止执行 # RELRO -z norelro # 关闭 -z lazy # 部分开启 -z now # 全部开启| GOT写保护 # CANARY -fno -stack-protector # 禁用 -fstack-protector # 开启 -fstack-protector-all # 完全开启| 堆栈溢出哨兵 # FORTIFY -D_FORTIFY_SOURCE &#x3D;1 # 较弱的检查 -D_FORTIFY_SOURCE&#x3D;2 # 较强的检查| 常用函数加强检查 # PIE(ASLR) -fpie -pie # 开启PIE，此时强度为1 -fPIE -pie # 开启PIE，此时为最高强度2| 代码段、数据段地址随机化 Ref Gcc 安全编译选项","categories":[{"name":"GCC","slug":"GCC","permalink":"http://gaclove.github.io/categories/GCC/"}],"tags":[{"name":"Linux GCC","slug":"Linux-GCC","permalink":"http://gaclove.github.io/tags/Linux-GCC/"}]}],"categories":[{"name":"tools","slug":"tools","permalink":"http://gaclove.github.io/categories/tools/"},{"name":"NVIDIA","slug":"NVIDIA","permalink":"http://gaclove.github.io/categories/NVIDIA/"},{"name":"GCC","slug":"GCC","permalink":"http://gaclove.github.io/categories/GCC/"}],"tags":[{"name":"port","slug":"port","permalink":"http://gaclove.github.io/tags/port/"},{"name":"ffmpeg","slug":"ffmpeg","permalink":"http://gaclove.github.io/tags/ffmpeg/"},{"name":"python web flask","slug":"python-web-flask","permalink":"http://gaclove.github.io/tags/python-web-flask/"},{"name":"NVIDIA","slug":"NVIDIA","permalink":"http://gaclove.github.io/tags/NVIDIA/"},{"name":"Linux GCC","slug":"Linux-GCC","permalink":"http://gaclove.github.io/tags/Linux-GCC/"}]}